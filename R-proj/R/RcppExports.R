# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Compute an inscribed ball of a convex polytope
#'
#' For a H-polytope described by a \eqn{m\times d} matrix \eqn{A} and a \eqn{m}-dimensional vector \eqn{b}, s.t.: \eqn{Ax\leq b}, this function computes the largest inscribed ball (Chebychev ball) by solving the corresponding linear program.
#' For a V-polytope \eqn{d+1} vertices that define a full dimensional simplex picked at random and the largest inscribed ball of the simplex is computed.
#' For a zonotope \eqn{P} we compute the minimum \eqn{r} s.t.: \eqn{ r e_i \in P} for all \eqn{i=1, \dots ,d}. Then the ball centered at the origin with radius \eqn{r/ \sqrt{d}} is an inscribed ball.
#'
#' @param P A convex polytope. It is an object from class (a) HPolytope or (b) VPolytope or (c) Zonotope.
#'
#' @return A \eqn{d+1}-dimensional vector that describes the inscribed ball. The first \eqn{d} coordinates corresponds to the center of the ball and the last one to the radius.
#'
#' @examples
#' # compute the Chebychev ball of a 2d unit simplex
#' P = GenSimplex(2,'H')
#' ball_vec = InnerBall(P)
#'
#' # compute the Chebychev ball of 3-dimensional cube in V-representation
#' P = GenCube(3, 'V')
#' ball_vec = InnerBall(P)
#' @export
InnerBall <- function(P) {
    .Call(`_volesti_InnerBall`, P)
}

#' Compute the percentage of the volume of the unit simplex that is contained in the intersection of a half-space and the unit simplex
#'
#' When a half-space \eqn{H} is given as a pair of a vector \eqn{a\in R^d} and a scalar \eqn{z0\in R} s.t.: \eqn{a^Tx\leq z0} this function calls the Ali's version of the Varsi formula.
#'
#' @param a A \eqn{d}-dimensional vector that defines the direction of the hyperplane.
#' @param z0 The scalar that defines the half-space.
#'
#' @references \cite{Varsi, Giulio,
#' \dQuote{The multidimensional content of the frustum of the simplex,} \emph{Pacific J. Math. 46, no. 1, 303--314,} 1973.}
#'
#' @references \cite{Ali, Mir M.,
#' \dQuote{Content of the frustum of a simplex,} \emph{ Pacific J. Math. 48, no. 2, 313--322,} 1973.}
#'
#' @return The percentage of the volume of the unit simplex that is contained in the intersection of the given half-space and the unit simplex
#'
#' @examples
#' # compute the frustum of H: -x1+x2<=0
#' a=c(-1,1)
#' z0=0
#' frustum = sliceOfSimplex(a, z0)
#' @export
SliceOfSimplex <- function(a, z0) {
    .Call(`_volesti_SliceOfSimplex`, a, z0)
}

#' Construct a copula using uniform sampling from the unit simplex
#'
#' Given two families of parallel hyperplanes (or a family of parallel hyperplanes and a family of concentric ellispoids centered at the origin) intersecting the canonical simplex, this function samples from the canonical simplex and construct an approximation of the bivariate probability distribution, called copula.
#'
#' @param h1 A \eqn{d}-dimensional vector that describes the direction of the first family of parallel hyperplanes.
#' @param h2 A \eqn{d}-dimensional vector that describes the direction of the second family of parallel hyperplanes.
#' @param numSlices The number of the slices for the copula. Default value is 100.
#' @param N The number of points to sample. Default value is \eqn{4\cdot 10^6}.
#'
#' @references \cite{L. Cales, A. Chalkis, I.Z. Emiris, V. Fisikopoulos,
#' \dQuote{Practical volume computation of structured convex bodies, and an application to modeling portfolio dependencies and financial crises,} \emph{Proc. of Symposium on Computational Geometry, Budapest, Hungary,} 2018.}
#'
#' @return A \eqn{numSlices\times numSlices} copula.
#' @examples
#' # compute a copula for two families of parallel hyperplanes
#' h1 = runif(n = 10, min = 1, max = 1000)
#' h1 = h1 / 1000
#' h2=runif(n = 10, min = 1, max = 1000)
#' h2 = h2 / 1000
#' cop = copula1(h1=h1, h2=h2, numSlices = 10, N = 100000)
#' @export
copula1 <- function(h1, h2, numSlices, N) {
    .Call(`_volesti_copula1`, h1, h2, numSlices, N)
}

#' Construct a copula using uniform sampling from the unit simplex
#'
#' Given two families of parallel hyperplanes (or a family of parallel hyperplanes and a family of concentric ellispoids centered at the origin) intersecting the canonical simplex, this function samples from the canonical simplex and construct an approximation of the bivariate probability distribution, called copula.
#'
#' @param h A \eqn{d}-dimensional vector that describes the direction of the first family of parallel hyperplanes.
#' @param E The \eqn{d\times d} symmetric positive define matrix that describes the family of concentric ellipsoids centered at the origin.
#' @param numSlices The number of the slices for the copula. Default value is 100.
#' @param N The number of points to sample. Default value is \eqn{4\cdot 10^6}.
#'
#' @references \cite{L. Cales, A. Chalkis, I.Z. Emiris, V. Fisikopoulos,
#' \dQuote{Practical volume computation of structured convex bodies, and an application to modeling portfolio dependencies and financial crises,} \emph{Proc. of Symposium on Computational Geometry, Budapest, Hungary,} 2018.}
#'
#' @return A \eqn{numSlices\times numSlices} copula.
#' @examples
#' # compute a copula for a family of parallel hyperplanes and a family of conentric ellipsoids
#' h = runif(n = 10, min = 1, max = 1000)
#' h = h / 1000
#' E = replicate(10, rnorm(20))
#' E = cov(E)
#' cop = copula2(h=h, E=E, numSlices=10, N=100000)
#' @export
copula2 <- function(h, E, numSlices, N) {
    .Call(`_volesti_copula2`, h, E, numSlices, N)
}

#' Compute the exact volume of (a) a zonotope (b) an arbitrary simplex (c) a unit simplex (d) a cross polytope (e) a hypercube
#'
#' Given a zonotope (as an object of class Zonotope), this function computes the sum of the absolute values of the determinants of all the \eqn{d \times d} submatrices of the \eqn{m\times d} matrix \eqn{G} that contains row-wise the segments that define the zonotope.
#' For an arbitrary simplex that is given in V-representation this function computes the absolute value of the determinant formed by the simplex's points assuming it is shifted to the origin.
#' For a \eqn{d}-dimensional unit simplex, hypercube or cross polytope this function computes the exact well known formulas.
#'
#' @param Z An object of class Zonotope.
#' @param exact A list that contains parameters for the exact volume computations. When a zonotope is given it should be null.
#' \itemize{
#'  \item{simplex }{A boolean parameter. It has to be TRUE when a simplex is given in V-representation or in order to compute the exact volume of a unit simplex.}
#'  \item{cube }{A boolean parameter. It has to be TRUE when the exact volume of a \eqn{d}-dimensional hypercube is requested.}
#'  \item{cross }{A boolean parameter. It has to be TRUE when the exact volume of a \eqn{d}-dimensional cross polytope is requested.}
#' }
#'
#' @return The exact volume of the zonotope
#' @examples
#'
#' # compute the exact volume of a 5-dimensional zonotope defined by the Minkowski sum of 10 segments
#' Z = GenZonotope(5, 10)
#' vol = exact_vol(Z)
#' @export
exact_vol <- function(P, body = NULL, Parameters = NULL) {
    .Call(`_volesti_exact_vol`, P, body, Parameters)
}

poly_gen <- function(kind_gen, Vpoly_gen, dim_gen, m_gen) {
    .Call(`_volesti_poly_gen`, kind_gen, Vpoly_gen, dim_gen, m_gen)
}

#' Classes to construct convex polytopes (H, V or zonotopes)
#'
#' @examples
#' # Create a 2-d unit simplex in H-representation
#' A = matrix(c(-1,0,0,-1,1,1), ncol=2, nrow=3, byrow=TRUE)
#' b = c(0,0,1)
#' P = Hpolytope$new(A,b)
#'
#' # Create a 3-d cube in V-representation
#' V = matrix(c(-1,1,-1,-1,-1,1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1,-1,-1), ncol=3, nrow=8, byrow=TRUE)
#' P = Vpolytope$new(V)
#'
#' # Create a 2-d zonotope with 4 generators
#' G = matrix(c(1,0,0,1,-0.73,0.67,-0.25,0.96), ncol = 2, nrow = 4, byrow = TRUE)
#' P = Zonotope$new(G)
NULL

#' Sample many points from a convex Polytope (H-polytope, V-polytope or a zonotope) or use direct methods for uniform sampling from unit simplex and hypersphere
#'
#' Sample N points from a H or a V-polytope or a zonotope with uniform or spherical gaussian -centered in an internal point- target distribution.
#' The \eqn{d}-dimensional unit simplex is the set of points \eqn{\vec{x}\in \R^d}, s.t.: \eqn{\sum_i x_i\leq 1}, \eqn{x_i\geq 0}. The \eqn{d}-dimensional canonical simplex is the set of points \eqn{\vec{x}\in \R^d}, s.t.: \eqn{\sum_i x_i = 1}, \eqn{x_i\geq 0}.
#'
#' @param P A convex polytope. It is an object from class (a) HPolytope or (b) VPolytope or (c) Zonotope.
#' @param N The number of points that the function is going to sample from the convex polytope. Default value is \eqn{100}.
#' @param distribution Optional. A list that contains parameters for the target distribution. Default distribution is uniform.
#' \itemize{
#'  \item{gaussian }{A boolean parameter. It declares spherical gaussian distribution as the target distribution. Default value is false.}
#'  \item{variance }{The variance for the spherical gaussian distribution. Default value is \eqn{1}.}
#' }
#' @param method Optional. A list that contains parameters for the random walk method. Default method is Coordinate Hit-and-Run.
#' \itemize{
#'  \item{direct }{A boolean parameter. It should be used for uniform sampling from the boundary or the interior of a hypersphere or from a unit or an arbitrary simplex. The arbitrary simplex has to be given as a V-polytope and the dimension should not be declared through method list. For the rest well known convex bodies it has to be declared the dimension and the type of body (simplex, sphere, ball).}
#'  \item{dim }{An integer that declares the dimension when direct flag is enabled for a unit simplex or a hypersphere (boundary or interior).}
#'  \item{body }{A string to request uniform sampling: (a) "simplex" to sample from an arbitrary simplex (when the simplex is given as a V-polytope) or a unit simplex (when no polytope is given and the dimension is declared), (b) "sphere" to sample from the boundary of a {d}-dimensional hypersphere centered at the origin and (c) to sample from the interior of the \eqn{d}-dimensional hypersphere centered at the origin. For (b) and (c) dimension should be given as well through method list.}
#'  \item{radius }{The radius of the \eqn{d}-dimensional hypersphere. Default value is \eqn{1}.}
#'  \item{WalkT }{A string to declare the random walk method: (a)"hnr" for Hit-and-Run or (b) "bw" for ball walk. Default method is Hit-and-Run.}
#'  \item{coord }{A boolean parameter for the hit-and-run. True for Coordinate Directions HnR, false for Random Directions HnR. Default value is TRUE.}
#'  \item{delta }{Optional. The radius for the ball walk.}
#'  \item{W }{Optional. The number of the steps for the random walk. Default value is \eqn{\lfloor 10+d/10\rfloor}.}
#' }
#' @param InnerPoint A \eqn{d}-dimensional numerical vector that defines a point in the interior of polytope P.
#'
#' @references \cite{R.Y. Rubinstein and B. Melamed,
#' \dQuote{Modern simulation and modeling} \emph{ Wiley Series in Probability and Statistics,} 1998.}
#' @references \cite{A Smith, Noah and W Tromble, Roy,
#' \dQuote{Sampling Uniformly from the Unit Simplex,} \emph{ Center for Language and Speech Processing Johns Hopkins University,} 2004.}
#' @references \cite{Art B. Owen,
#' \dQuote{Monte Carlo theory, methods and examples,} \emph{ Copyright Art Owen,} 2009-2013.}
#'
#' @return A \eqn{d\times N} matrix that contains, column-wise, the sampled points from the convex polytope.
#' @examples
#' # uniform distribution from a 3d cube in V-representation using ball walk
#' P = GenCube(3, 'V')
#' points = sample_points(P, method = list("WalkT"="bw", "W"=5))
#'
#' # gaussian distribution from a 2d unit simplex in H-representation with variance = 2
#' A = matrix(c(-1,0,0,-1,1,1), ncol=2, nrow=3, byrow=TRUE)
#' b = c(0,0,1)
#' P = HPolytope(A=A, b=b)
#' points = sample_points(P, distribution = list("gaussian"=TRUE, "variance"=2))
#' @export
sample_points <- function(P = NULL, N = NULL, WalkType = NULL, walk_len = NULL, exact = NULL, body = NULL, Parameters = NULL, distribution = NULL, InnerPoint = NULL) {
    .Call(`_volesti_sample_points`, P, N, WalkType, walk_len, exact, body, Parameters, distribution, InnerPoint)
}

#' The main R function for volume approximation of a convex Polytope (H-polytope, V-polytope or a zonotope)
#'
#' For the volume approximation can be used two algorithms. Either SequenceOfBalls or CoolingGaussian. A H-polytope with \eqn{m} facets is described by a \eqn{m\times d} matrix \eqn{A} and a \eqn{m}-dimensional vector \eqn{b}, s.t.: \eqn{Ax\leq b}. A V-polytope is described as a set of \eqn{d}-dimensional points. A zonotope is desrcibed by the Minkowski sum of \eqn{d}-dimensional segments.
#'
#' @param P A convex polytope. It is an object from class (a) HPolytope or (b) VPolytope or (c) Zonotope.
#' @param walk_length Optional. The number of the steps for the random walk. Default value is \eqn{\lfloor 10 + d/10\rfloor} for SequenceOfBalls and \eqn{1} for CoolingGaussian.
#' @param error Optional. Declare the goal for the approximation error. Default value is \eqn{1} for SequenceOfBalls and \eqn{0.2} for CoolingGaussian.
#' @param InnerBall Optional. A \eqn{d+1} vector that containes an inner ball. The first \eqn{d} coordinates corresponds to the center and the last one to the radius of the ball. If it is not given then for H-polytopes the Chebychev ball is computed, for V-polytopes \eqn{d+1} vertices are picked randomly and the Chebychev ball of the defined simplex is computed. For a zonotope that is defined by the Minkowski sum of \eqn{m} segments we compute the maximal \eqn{r} s.t.: \eqn{re_i\in Z} for all \eqn{i=1,\dots ,d}, then the ball centered at the origin with radius \eqn{r/\sqrt{d}} is an internal ball.
#' @param Algo Optional. A list that contains parameters for the CoolingGaussian algorithm. When it is null SequenceOfBalls is used as the default.
#' \itemize{
#'  \item{CG }{A boolean element. When it is true CoolingGaussian algorithm is used.}
#'  \item{win_len }{The size of the window for the ratios' approximation in CG algorithm. Default value is \eqn{4 \cdot dimension^2 + 500}.}
#'  \item{C }{A constant for the lower bound of \eqn{variance/mean^2} in schedule annealing of CG algorithm. Default value is \eqn{2}.}
#'  \item{N }{The number of points we sample in each step of schedule annealing in CG algorithm. Default value is \eqn{500C + dimension^2 / 2}.}
#'  \item{ratio }{Parameter of schedule annealing of CG algorithm, larger ratio means larger steps in schedule annealing. Default value is \eqn{1 - 1/dimension}.}
#'  \item{frac }{The fraction of the total error to spend in the first gaussian in CG algorithm. Default value is \eqn{0.1}.}
#' }
#' @param WalkType Optional. A list that contains parameters for the random walk method.
#' \itemize{
#'  \item{method}{A string that declares the method: (a) "hnr" for Hit-and-Run or (b) "bw" for ball walk. Default method is Hit-and-Run.}
#'  \item{coordinate}{A boolean parameter for Hit-and-Run. It has to be TRUE for Cordinate Directions Hit-and-Run or FALSE for Random Directions Hit-and-Run. Default method is Coordinate Directions Hnr.}
#'  \item{delta}{The radius for the ball walk.}
#' }
#' @param rounding Optional. A boolean parameter to activate the rounding option. Default value is false.
#'
#' @references \cite{I.Z.Emiris and V. Fisikopoulos,
#' \dQuote{Practical polytope volume approximation,} \emph{ACM Trans. Math. Soft.,} 2014.},
#' @references \cite{B. Cousins and S. Vempala, \dQuote{A practical volume algorithm,} \emph{Springer-Verlag Berlin Heidelberg and The Mathematical Programming Society,} 2015.}
#'
#'
#' @return The approximation of the volume of a convex polytope.
#' @examples
#' # calling SOB algorithm for a H-polytope (2d unit simplex)
#' P = GenSimplex(2,'H')
#' vol = volume(P)
#'
#' # calling CG algorithm for a V-polytope (3d cube)
#' P = GenSimplex(2,'V')
#' vol = volume(P, Algo = list("CG"=TRUE))
#'
#' # calling CG algorithm for a 5-dimensional zonotope defined as the Minkowski sum of 10 segments
#' Z = GenZonotope(2, 4)
#' vol = volume(Z, WalkType = list("method"="hnr", "coordinate"=FALSE, "W"=5), rounding=TRUE)
#' @export
volume <- function(P, walk_len = NULL, error = NULL, InnerBall = NULL, Algo = NULL, WalkType = NULL, rounding = NULL, Parameters = NULL) {
    .Call(`_volesti_volume`, P, walk_len, error, InnerBall, Algo, WalkType, rounding, Parameters)
}

